# Behavior Graph Vision

In the context of interactive software, relative to the status quo, we believe using Behavior Graph improves:

* developer experience
* software quality
* understanding of how the solution maps to the problem
* communication between teammates working on the same code base

It is therefore prudent to offer it to all developers.
This means every developer needs to be aware of it, know how to use it, and having it available on their platform of choice.

Because the ideas are generally applicable to any programming language ideally it would be taught in schools as a standard technique. 
Additionally programming languages themselves should have enough support so programmers could express their intent directly and the computer could run Behavior Graph code efficiently.
Lastly programmers should expect that their development environments to have robust tooling support by default.

In a perfect world everyone would naturally adopt the "best" ideas; however, competing needs means "best" is unique for each developer.
The goal of this project is to understand and accommodate those needs while adhering to the core value proposition of Behavior Graph.

While any individual should feel free to explore their interests, the following high level goals point to the important work for this one main goal.

## Love the Problem

Developing interactive software is difficult.
Behavior Graph strives to make it possible to develop quality interactive software while enjoying the process.

* Be open to changes that align with this goal.
* Avoid changes that distract from this goal.
* Reject programmer animosity towards alternate perspectives and projects.
It is a distraction at best, and it is always a missed opportunity to learn.

## Stick to the Basics

Behavior Graph takes a particular stance on the roles of state and change in interactive software.
Resources, Behaviors, and Extents together make up this stance.
Bikeshedding over details is fine.
Veering away from these basic concepts means you are working something else.

Behavior Graph should stay focused:
* It remains portable to more platforms
* It is easier to optimize
* There are fewer things to teach/learn
* There are fewer unintended interactions

## Become Boring

When Behavior Graph becomes [boring](https://mcfunley.com/choose-boring-technology), then we know we have achieved our goal.

## Minimize Friction

Friction happens when a developer spends time on Behavior Graph problems and not their actual problems.
Small annoyances add up.

Aspire to:
* minimal boilerplate
* convenient syntax
* compositional APIs
* readability
* navigatability
* debugability
* tooling
* actionable errors

The developer should never be stuck without a workaround.

## Documentation

Good documentation scales in time and space.

Every mistake or missing element damages the reputation of the documentation as a whole and all the work people have put into it.

It should feels native to the programming language or platform it targets.

It should evolve continuously to absorb community knowledge.
If Google and StackOverflow become the defacto documentation then we cannot control the quality or presentation.

## Precise Language

Behavior Graph operates at a level where people describe their solutions in terms of resources and behaviors.
They should be able to express their ideas fluently so they can communicate effectively with each other.
This requires a precise vocabulary, examples of communication, and reference material.

## Communication

Communication is empathy.
Developers can't use Behavior Graph if they don't know about it.
This requires:

* Active advocacy
* Clear examples and explanations
* Creating connections via things people already know about
* Remembering that not everyone speaks English

Developers won't use it if they believe untrue negative things about it. 
People can be mean on the internet so we should not let unfounded attacks on that reputation remain undefended.
We should also not let trolls bring out bad behavior.
Lots of positive information easily drowns out the occasional negative.

## Contribution

Contribution doesn't just happen.
We must actively engage with it.

* Set up systems to enable contributors
  * Ideas to explore
  * Work to be done
  * Share progress and activity
  * Learning to contribute
  * Contribution documentation
* Communication is contribution: teaching, writing, podcasting, running workshops, presenting, and word of mouth
* Help contributors have a sense of ownership
* Anti-exclusive
* Systemetize maintenance work
* Community is contribution

## Performance

Behavior Graph works at a pretty low level, so it should be as fast as possible.

## Liveness

Behavior Graph should appear active even when it is already perfect.

## Native

The ideas in Behavior Graph should work fine on any language and platform.
However, if it feels foreign, developers will reject it.

* Implement Behavior Graph in the target language.
* Use native distribution mechanisms.
* Use native idioms.
* Ideally make it a part of an existing trusted organization (eg Boost).
* Even better, make it part of the standard library.
* Even better, make it part of the language itself.

## Resources

### Project

* [Podcast episode on tech evangelism](https://overcast.fm/+LfVMvIuHA)
* Crossing the Chasm, book
* [Elinor Ostrom's 8 Principles for Managing A Commmons | On the Commons](https://www.onthecommons.org/magazine/elinor-ostroms-8-principles-managing-commmons)
* [Making is show business](https://alexdanco.com/2020/10/08/making-is-show-business-now/)
* Achievements to help organize what to learn?

### Tools
* [Jointjs](https://www.jointjs.com) paid for js library for building diagramming tools.
* [roughjs](https://roughjs.com) js library for hand drawn feel diagrams


